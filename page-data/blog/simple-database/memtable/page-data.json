{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/simple-database/memtable","result":{"data":{"markdownRemark":{"html":"<p>Now that we have finished <a href=\"/blog/simple-database/motivation-design\">outlining our motivations and designs of our database</a>, we will start by building our first component, the MemTable. The MemTable is the first layer in our database and where records are immediately stored. We will discuss the design choices RocksDB made for their database and what benefits came with those choices. Additionally, we will look at the benefits and drawbacks of our MemTable. Finally, we will implement our MemTable in Rust.</p>\n<h2>What is the MemTable?</h2>\n<p>The MemTable (aka. Memory Table) is the in-memory cache of the latest set of record writes applied to the database. Simply, it is a container, whether that be a <a href=\"https://en.wikipedia.org/wiki/Dynamic_array\">Vector</a>, <a href=\"https://en.wikipedia.org/wiki/Linked_list\">Linked-List</a>, or any other container, that holds the written records sorted, in total order, by key. By sorting the records, lookups and scans in the MemTable can be done efficiently using a data structure that supports a <code class=\"language-text\">O(Log N)</code> access pattern.</p>\n<p>At their core, LSM-Tree databases take a random I/O problem in a B-Tree model and turn it into a sequential I/O problem, which is much faster. This is achieved by batching the writes for updated records. The MemTable does this working in coordination with two methods: the Write Ahead Log(WAL) and the Sorted String Table(SSTable). First, the WAL holds a replica of the MemTable so we can be assured that our data is intact in the event of a restart. Instead of storing the MemTable byte-for-byte, the WAL stores a running log of the operations applied to the database, hence its name. By replaying the operations stored in the WAL, the MemTable can be recovered. Second, the SSTables are created to store MemTables once they have reached capacity. Again, this writes all of the records to disk in one go, eliminating the need for random disk writes.</p>\n<h2>RocksDB MemTable</h2>\n<p>Looking at RocksDB, the database our database is based on, <a href=\"https://github.com/facebook/rocksdb/wiki/MemTable\">their MemTable</a> uses a <a href=\"https://en.wikipedia.org/wiki/Skip_list\">SkipList</a> by default. A SkipList is very similar to a linked list but with many additional links. The first layer of links matches a LinkedList. Additional layers are created by selecting a progressively smaller subset of elements from the prior layer. The additional layers are LinkedLists that skip elements. </p>\n<p>When performing a search, the function starts at the most sparse layer and moves to lower layers when the next skip connection overshoots the target. The probabilistic nature of a SkipList creates a data structure that can be searched in <code class=\"language-text\">O(Log N)</code> average worst case time. Immediately, we can see the benefits of using a SkipList over a Vector. SkipLists provide the fast <code class=\"language-text\">O(Log N)</code> access of a Vector without the <code class=\"language-text\">O(N)</code> worst-case time for inserts. Although some will point out a Vector can be “amortized” across many inserts to a constant factor, databases have strict latency guarantees that prevent them from using amortization as a shield. </p>\n<p>RocksDB’s implementation of a MemTable shows us the pinnacle of database design and is the result of a relentless push for performance. </p>\n<h2>Our MemTable</h2>\n<p>Since we aren’t looking for maximum performance and waste our time watching me write a SkipList in Rust, we are going to use a Vector. Like stated above, a Vector takes a performance hit on inserts, which is acceptable for our purposes. The <code class=\"language-text\">Vec</code> struct is well rounded and has many helper functions that make building our MemTable a lot easier. Along with being in the standard library, Vectors are easy to follow — it’s a list — and we can efficiently search them using <a href=\"https://en.wikipedia.org/wiki/Binary_search_algorithm\">Binary Search</a>. Overall, a Vector provides the minimum functionality to serve as the basis of our MemTable while being simple enough to get started with.</p>\n<h3>Building Our MemTable</h3>\n<p>Assuming Rust and Cargo are installed on your machine, we can commence building our database with:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ cargo new database-engine --lib</code></pre></div>\n<p>In the <a href=\"/blog/simple-database/motivation-design\">Motivations section</a> of this series, I mentioned one of the reasons I’m doing this is to learn Rust. I could spend a lot of time and explain how Rust does ownership, but I don’t feel this is the venue to do that. If you are still trying to learn the basics of Rust and its ownership rules, read <a href=\"https://doc.rust-lang.org/book/\">The Book</a> first to get a better understanding before embarking on building a database. While I expect a basic understanding of Rust, I will mention ownership decisions when they appear to be ambiguous or have effects on other components. </p>\n<h3>MemTable Struct</h3>\n<p>Getting started, the first struct for our MemTable is self explanatory. Our MemTable needs to satisfy two needs: a container of our write operations and a counter for its size.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token comment\">/// MemTable holds a sorted list of the latest written records.</span>\n<span class=\"token comment\">///</span>\n<span class=\"token comment\">/// Writes are duplicated to the WAL for recovery of the MemTable in the event of a restart.</span>\n<span class=\"token comment\">///</span>\n<span class=\"token comment\">/// MemTables have a max capacity and when that is reached, we flush the MemTable</span>\n<span class=\"token comment\">/// to disk as a Table(SSTable).</span>\n<span class=\"token comment\">///</span>\n<span class=\"token comment\">/// Entries are stored in a Vector instead of a HashMap to support Scans.</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">struct</span> <span class=\"token type-definition class-name\">MemTable</span> <span class=\"token punctuation\">{</span>\n  entries<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Vec</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">MemTableEntry</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  size<span class=\"token punctuation\">:</span> <span class=\"token keyword\">usize</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The MemTable struct fits our requirements with a <code class=\"language-text\">Vec&lt;MemTableEntry&gt;</code> and a simple size counter. In the docs, I mention why a HashMap isn’t used. Lookups and edits would be constant time, but scans would involve extracting and sorting the entries of the table, an unacceptable tradeoff.</p>\n<h3>MemTableEntry Struct</h3>\n<p>Inside the Vector are <code class=\"language-text\">MemTableEntry</code>s with the modified record information.   </p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token comment\">/// MemTable entry.</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">struct</span> <span class=\"token type-definition class-name\">MemTableEntry</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">pub</span> key<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Vec</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">u8</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">pub</span> value<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Option</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">Vec</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">u8</span><span class=\"token operator\">>></span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">pub</span> timestamp<span class=\"token punctuation\">:</span> <span class=\"token keyword\">u128</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">pub</span> deleted<span class=\"token punctuation\">:</span> <span class=\"token keyword\">bool</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The Key and Value don’t need much explanation. The Timestamp is the time this write occurred in microseconds and is used to order writes to the same key when cleaning our old data in SSTables. In order to support fast deletes, we have Tombstones for deleted records. With Tombstones, a value isn’t necessary for these <code class=\"language-text\">MemTableEntry</code>s; thus, we can make it optional.</p>\n<h3>MemTable Impl</h3>\n<p>With the structs out of the way,  we can get to building the methods, the functionality, of our MemTable.  </p>\n<h4>new()</h4>\n<p>First, we need a way to create new MemTables.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token comment\">/// Creates a new empty MemTable</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">new</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token class-name\">MemTable</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token class-name\">MemTable</span> <span class=\"token punctuation\">{</span>\n    entries<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Vec</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    size<span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>get_index()</h4>\n<p>When we access the MemTable for gets, sets, and deletes, we need to run a Binary Search over the entries of the MemTable. Rust is nice enough to include a Binary Search implementation in the Vec standard library. This function is necessary to explicitly find a record in question or find an acceptable index a record can be inserted at while maintaining the total order of the records in the MemTable. </p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token comment\">/// Performs Binary Search to find a record in the MemTable.</span>\n<span class=\"token comment\">///</span>\n<span class=\"token comment\">/// If the record is found `[Result::Ok]` is returned, with the index of record. If the record is not</span>\n<span class=\"token comment\">/// found then `[Result::Err]` is returned, with the index to insert the record at.</span>\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">get_index</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">u8</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token class-name\">Result</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">usize</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">usize</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">self</span>\n    <span class=\"token punctuation\">.</span>entries\n    <span class=\"token punctuation\">.</span><span class=\"token function\">binary_search_by_key</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>key<span class=\"token punctuation\">,</span> <span class=\"token closure-params\"><span class=\"token closure-punctuation punctuation\">|</span>e<span class=\"token closure-punctuation punctuation\">|</span></span> e<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">as_slice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This helper function reduces the amount of code maintenance necessary if we want to change the sort field. </p>\n<h4>set()</h4>\n<p>To set a Key-Value pair in the database, we need to find the entry in the MemTable with the same key to overwrite it or find the position where we can insert a new entry. Here, we can see how our helper function, <code class=\"language-text\">get_index(&amp;self, key: &amp;[u8])</code>, simplifies this process.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token comment\">/// Sets a Key-Value pair in the MemTable.</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">set</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">u8</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">u8</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> timestamp<span class=\"token punctuation\">:</span> <span class=\"token keyword\">u128</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> entry <span class=\"token operator\">=</span> <span class=\"token class-name\">MemTableEntry</span> <span class=\"token punctuation\">{</span>\n    key<span class=\"token punctuation\">:</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">to_owned</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    value<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">.</span><span class=\"token function\">to_owned</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    timestamp<span class=\"token punctuation\">,</span>\n    deleted<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">match</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span><span class=\"token function\">get_index</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Ok</span><span class=\"token punctuation\">(</span>idx<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// If a Value existed on the deleted record, then add the difference of the new and old Value to the MemTable's size.</span>\n      <span class=\"token keyword\">if</span> <span class=\"token keyword\">let</span> <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>entries<span class=\"token punctuation\">[</span>idx<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">.</span><span class=\"token function\">as_ref</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> value<span class=\"token punctuation\">.</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> v<span class=\"token punctuation\">.</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">-=</span> v<span class=\"token punctuation\">.</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> value<span class=\"token punctuation\">.</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">+=</span> value<span class=\"token punctuation\">.</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> v<span class=\"token punctuation\">.</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>entries<span class=\"token punctuation\">[</span>idx<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> entry<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token class-name\">Err</span><span class=\"token punctuation\">(</span>idx<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">+=</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> value<span class=\"token punctuation\">.</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">16</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Increase the size of the MemTable by the Key size, Value size, Timestamp size (16 bytes), Tombstone size (1 byte).</span>\n      <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>entries<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>idx<span class=\"token punctuation\">,</span> entry<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Using get_index, we can either get an <code class=\"language-text\">Ok</code> or <code class=\"language-text\">Err</code> for the records existence in the Vector. If the <code class=\"language-text\">Result</code> is <code class=\"language-text\">Ok</code>, we overwrite the entry in the MemTable and update the total size of the MemTable. If the <code class=\"language-text\">Result</code> is <code class=\"language-text\">Err</code>, we insert the entry at the index returned and add the size of the entry the total size of the MemTable.</p>\n<h4>delete()</h4>\n<p>Deleting a record from our database is very similar to setting a Key-Value pair, just without the Value. Even if the value doesn’t exist in the MemTable we have to insert the Tombstone record because this record may exist in the SSTables. Keeping Tombstones allows the database to clean up deleted records during Compaction.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token comment\">/// Deletes a Key-Value pair in the MemTable.</span>\n<span class=\"token comment\">///</span>\n<span class=\"token comment\">/// This is achieved using tombstones.</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">delete</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">u8</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> timestamp<span class=\"token punctuation\">:</span> <span class=\"token keyword\">u128</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> entry <span class=\"token operator\">=</span> <span class=\"token class-name\">MemTableEntry</span> <span class=\"token punctuation\">{</span>\n    key<span class=\"token punctuation\">:</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">to_owned</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    value<span class=\"token punctuation\">:</span> <span class=\"token class-name\">None</span><span class=\"token punctuation\">,</span>\n    timestamp<span class=\"token punctuation\">:</span> timestamp<span class=\"token punctuation\">,</span>\n    deleted<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">match</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span><span class=\"token function\">get_index</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Ok</span><span class=\"token punctuation\">(</span>idx<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// If a Value existed on the deleted record, then subtract the size of the Value from the MemTable.</span>\n      <span class=\"token keyword\">if</span> <span class=\"token keyword\">let</span> <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>entries<span class=\"token punctuation\">[</span>idx<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">.</span><span class=\"token function\">as_ref</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">-=</span> value<span class=\"token punctuation\">.</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>entries<span class=\"token punctuation\">[</span>idx<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> entry<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token class-name\">Err</span><span class=\"token punctuation\">(</span>idx<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>size <span class=\"token operator\">+=</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">16</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Increase the size of the MemTable by the Key size, Timestamp size (16 bytes), Tombstone size (1 byte).</span>\n      <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>entries<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>idx<span class=\"token punctuation\">,</span> entry<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The only differences are no Value and slightly less size update logic. </p>\n<h4>get()</h4>\n<p>To retrieve an entry, we search the Vector using Binary Search. </p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token comment\">/// Gets a Key-Value pair from the MemTable.</span>\n<span class=\"token comment\">///</span>\n<span class=\"token comment\">/// If no record with the same key exists in the MemTable, return None.</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">get</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">u8</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token class-name\">Option</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">&amp;</span><span class=\"token class-name\">MemTableEntry</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token keyword\">let</span> <span class=\"token class-name\">Ok</span><span class=\"token punctuation\">(</span>idx<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span><span class=\"token function\">get_index</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>entries<span class=\"token punctuation\">[</span>idx<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token class-name\">None</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Once we get the result from <code class=\"language-text\">get_index()</code>, we wrap the response in an <code class=\"language-text\">Option</code>. In this case, we return a reference because we don’t want other parts of the database modifying the data inside the MemTable.</p>\n<h2>Conclusion</h2>\n<p>The MemTable, the first component of our database, is simple on the surface but disguises many design tradeoffs. RocksDB — in its drive to deliver consistency performance with SkipLists — shows us the lengths that production databases designers go to. Although we weren’t shooting for performance, our MemTable delivered <code class=\"language-text\">O(Log N)</code> searches and <code class=\"language-text\">O(N)</code> inserts using a Vector. <a href=\"https://github.com/adambcomer/database-engine/blob/master/src/mem_table.rs\">The complete MemTable component can be found in this repository along with a set of unit tests</a>. Next, we will implement the WAL component of our database so we can recover the MemTable when our database restarts.</p>\n<h2>Index</h2>\n<ul>\n<li><a href=\"/blog/simple-database/motivation-design\">Build a Database Pt. 1: Motivation &#x26; Design</a></li>\n<li>Build a Database Pt. 2: MemTable</li>\n<li><a href=\"/blog/simple-database/wal\">Build a Database Pt. 3: Write Ahead Log(WAL)</a></li>\n</ul>","frontmatter":{"formattedDate":"Jan 24, 2021","date":"2021-01-24T19:45:04+0000","postDate":"2020-06-12T00:18:28+0000","slug":"/blog/simple-database/memtable","title":"Build a Database Pt. 2: MemTable","description":"Build the first component of an LSM-Tree database, the MemTable. We look at how RocksDB designed their MemTable and build our own.","image":"/assets/img/simple-database-memtable-cover.jpg","author":"Adam Comer"}},"file":null},"pageContext":{"slug":"/blog/simple-database/memtable","image":"/assets/img/simple-database-memtable-cover.jpg"}},"staticQueryHashes":[]}